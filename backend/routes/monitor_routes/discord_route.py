import os
import requests
import logging
from datetime import datetime

import pytz
from fastapi import Depends, HTTPException
from sqlalchemy.orm import Session

from database.AuthDB import get_db, Website
from services.uptime_service import uptime_service
from .stats_route import get_uptime_stats  # reuse the stats function

logger = logging.getLogger(__name__)

DISCORD_WEBHOOK_URL = os.getenv("DISCORD_WEBHOOK_URL")
MAIN_URL = os.getenv("MAIN_URL")


def register(router):
    @router.get("/discord")
    async def send_discord_report(db: Session = Depends(get_db)):
        if not DISCORD_WEBHOOK_URL:
            raise HTTPException(status_code=400, detail="DISCORD_WEBHOOK_URL not set in .env")
        try:
            # Get website info
            website = db.query(Website).filter(Website.id == uptime_service.website_id).first()
            print(website.url if website else None)
            stats = None
            try:
                stats = await get_uptime_stats(db)
            except Exception:
                stats = None

            # SSL report
            ssl_status = "Unknown"
            ssl_expiry = "Unknown"
            ssl_days_remaining = "N/A"
            ssl_info = uptime_service.get_ssl_certificate_info(MAIN_URL if website else None)
            print(ssl_info)
            if ssl_info:
                ssl_expiry = ssl_info.get('valid_till') or "Unknown"
                days_left = ssl_info.get('days_left')
                if days_left is not None:
                    try:
                        days_left_int = int(days_left)
                        if days_left_int >= 0:
                            ssl_status = "Valid"
                            ssl_days_remaining = f"{days_left_int} days"
                        else:
                            ssl_status = "Expired"
                            ssl_days_remaining = f"Expired {-days_left_int} days ago"
                    except Exception:
                        ssl_days_remaining = str(days_left)
                else:
                    ssl_days_remaining = "N/A"
                if ssl_info.get('cert_exp') is True:
                    ssl_status = "Expired"

            website_name = website.name if website else "Unknown"
            website_url = website.url if website else "Unknown"
            uptime_percentage = stats.uptime_percentage if stats else "N/A"
            total_checks = stats.total_checks if stats else "N/A"
            successful_checks = stats.successful_checks if stats else "N/A"
            avg_response = stats.average_response_time if stats else "N/A"
            last_check = stats.last_check.strftime('%Y-%m-%d %H:%M:%S UTC') if stats and stats.last_check else "N/A"

            # Local Dhaka time
            local_tz = pytz.timezone('Asia/Dhaka')
            utc_now = datetime.utcnow()
            local_time = utc_now.replace(tzinfo=pytz.utc).astimezone(local_tz)
            formatted_local_time = local_time.strftime('%Y-%m-%d %I:%M:%S %p GMT+6')

            last_check_local = last_check
            if stats and stats.last_check:
                try:
                    if stats.last_check.tzinfo is None:
                        utc_last_check = stats.last_check.replace(tzinfo=pytz.utc)
                    else:
                        utc_last_check = stats.last_check.astimezone(pytz.utc)
                    local_last_check = utc_last_check.astimezone(local_tz)
                    last_check_local = local_last_check.strftime('%Y-%m-%d %I:%M:%S %p GMT+6')
                except Exception:
                    last_check_local = last_check

            message = f"""
:bar_chart: **Website Maintenance Report**
Website: {website_name}
URL: {website_url}
Uptime: {uptime_percentage}%
Total Checks: {total_checks}
Successful Checks: {successful_checks}
Avg Response Time: {avg_response} ms
Last Check: {last_check_local}
SSL Status: {ssl_status}
SSL Expiry: {ssl_expiry}
SSL Days Left: {ssl_days_remaining}
-----------------------------------
_Automated report generated by **TheWatcher** on {formatted_local_time}_
"""

            response = requests.post(DISCORD_WEBHOOK_URL, json={"content": message})
            response.raise_for_status()
            return {"status": "success", "detail": "Maintenance report sent to Discord."}
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to send Discord report: {e}")
